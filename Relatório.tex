\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc}%Pacote para acentuação
\usepackage[brazil]{babel} % Escrita em português brasileiro.
\usepackage[lmargin=3cm,tmargin=3cm,rmargin=2cm,bmargin=2cm]{geometry} %Formato que lembra a ABNT
\usepackage[T1]{fontenc} %Ajusta o texto que vem de outras fontes
\usepackage{amsmath,amsthm,amsfonts,amssymb,dsfont,mathtools,blindtext} %pacotes matemáticos
\title{Relatório de IC}
\usepackage{indentfirst}

\begin{document}

\maketitle

\section{Resumo}

\section{Palavras-chave}

\section{Introdução}
    Podemos dizer que a otimização é formada por uma tomada de decisões onde busca otimizar um ou mais objetos sob um conjunto de circunstâncias. Logo, dizemos que tais otimizações sempre fizeram parte da nossa vivência, sendo tais onipresentes na natureza, visto que, utilizamos parâmetros de decisões para vários problemas do nosso cotidiano.

    Um método que propõe a otimização de um sistema de dimensões com vários parâmetros seria o de “Metaheurísticas”. Tal procedimento é uma técnica independente de resolução de problemas que não levam vantagem de qualquer especificidade. Esse método pode ser baseado em vizinhança ou baseado em população.
    
    Na evolução diferencial (ED) utilizamos tal proposta de forma que trabalhamos por partes, sendo tais a de inicialização e evolução. Na inicialização, geramos uma população aleatória para conseguirmos aplicar dentro dos parâmetros, logo após partimos para a segunda fase pegamos a população gerada e aplicamos em um processo de mutação, cruzamento e processos de seleção que se repetem até um critério de rescisão seja cumprido.
    
    Quando avaliamos um critério de otimização passamos pela premissa de testes, que buscam avaliar o desempenho de um algoritmo que possui um extenso conjunto de funções de teste. Um procedimento de resolução de problemas seria o benchmark com base em propriedades, modalidade e escalabilidade etc. Ele pode incluir padrões como, Rosenbrock, Rastrigin, Sphere e muito mais. 
    
    O DE vem se modificando e aperfeiçoando desde sua concepção. Para melhorar ainda mais seu desempenho em otimização complexa de problemas. Tais que seguem as etapas de alinhamento populacional, mutação, cruzamento e seleção.


\section{Metodologia}

\subsection{Treinamento de programas que serão utilizados ao longo do projeto.}

  A metodologia utilizada nesta pesquisa se divide em algumas
  etapas sendo elas as de treinamento, implementação, teste e incorporação.
  Primeiramente começamos com a implementação do treinamento do programa linux através de reuniões semanais assíncronas, onde o professor ensina a desenvolver  comandos básicos como scripts, strings e bash que logo serão utilizados para compartilhamento de dados da pesquisa.
  Em seguida começando o plano de estudo dirigido de python, onde através de ***arquivos de diretórios python***, e com ajuda da disciplina de Lógica de Programação, pude desenvolver algumas habilidades de operadores aritméticos, módulos, funções, condições e estruturas de repetição.
  Também tivemos uma breve introdução de supercomputadores através de um encontro assíncrono, compreendemos um pouco sobre cluster’s (supercomputadores) onde vimos um pouco de Machine Learning através do NPAD.

\subsection{Implementação do algoritmo em códigos.}

 Após a fase de treinamento, começamos a desenvolver a implementação de um código de algoritmo orientado a objeto, no qual introduzimos a \textbf{Differential Evolution (DE)}, que se trata de um método de otimização de um problema, onde ele tenta encontrar um função que máximiza ou minimiza o problema. Em que um individuo \textbf{x} população cria novas soluções de candidatos, combinando as existentes de acordo com a fórmula, gerando uma melhor pontuação para problemas de otimização.
 o DE funciona da seguinte maneira 


Inicialização > Mutação > Recombinação > Seleção > Mutação > Recombinação > Seleção > Mutação %transformar em uma imagem


 O programa se repete até obter seus melhores critérios de parada onde ocorre através do: \textbf{NP} (Number Parents), \textbf{CR} $\in$ \textbf{[0,1]} (Crossover Probability) e   \textbf{F} $\in$ \textbf{[0.2]} (parâmetro do peso diferencial). Configurações típicas como \textbf{F = 0.8}  e  \textbf{CR = 0.9}. Logo a optimização da performance fornece agentes \textbf{X} aleatórios, dos quais rodam em um espaço de busca até seus requisitos serem atendidos. A escolha de três agentes vetoriais são escolhidas. Em seguida escolhemos um índice de dimensão aleatório, computamos tudo é jogamos na fórmula do 
 
 yi = ai + Fx (bi - ci)% colocar em forma de equação, não consegui

 sendo \textbf{a, b e c} os vetores escolhidos aleatoriamente levando em consideração de \textbf{ri <CR} ou  \textbf{i = R}. De caso \textbf{f(y) <= f(x)} substituímos o agente \textbf{x} na população pela melhor solução.
 
 
\section{Resultados e Discussoes}

\section{Conclusão}

\section{Referências}

\end{document}
